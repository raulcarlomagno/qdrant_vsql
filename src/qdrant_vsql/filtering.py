import datetime
from typing import Any, Union, Optional, List, Dict, Tuple, cast

from parsimonious.grammar import Grammar
from parsimonious.nodes import Node, NodeVisitor
from qdrant_client.http import models

# Define magic values for list indices
FILTERED_ID_OP_VALUE_LEN = 3
VISITED_CHILDREN_VALUE_INDEX = 2
VISITED_CHILDREN_TAIL_INDEX = 3
VISITED_CHILDREN_NOT_OP_INDEX = 4

# Define the grammar for the SQL-like WHERE clause using Parsimonious PEG format.
# This grammar defines the structure of valid queries.
# Updated to be more specific and less ambiguous.
qdrant_filter_grammar = Grammar(
    r"""
    # Entry rule for the entire expression
    expression = factor (ws (OR / AND) ws factor)*

    # A factor can be a NOT of any grouped or atomic condition
    factor = (NOT ws)? (condition / ("(" ws expression ws ")"))

    # A condition can be one of several types. Order is important for parsing.
    condition = is_null_condition / is_empty_condition / is_empty_array_condition / values_count_condition / has_id_condition / comparison

    # Comparison operators and their operands, now including BETWEEN and NOT IN/NOT BETWEEN
    comparison = identifier ws comparison_op
    comparison_op = (not_in_op ws value) / (not_between_op ws value ws AND ws value) / (gte ws value) / (lte ws value) / (gt ws value) / (lt ws value) / (equals ws value) / (not_equals ws value) / (in_op ws value) / (like_op ws value) / (between_op ws value ws AND ws value)

    # Specific condition types with more precise matching
    is_null_condition = identifier ws IS ws NOT? ws NULL
    is_empty_condition = identifier ws IS ws EMPTY
    is_empty_array_condition = identifier ws equals ws "[]"
    # has_id_condition now explicitly matches the 'id' keyword
    has_id_condition = "id" ws (equals / in_op) ws value
    values_count_condition = COUNT "(" ws identifier ws ")" ws values_count_op
    values_count_op = (gte ws number) / (lte ws number) / (gt ws number) / (lt ws number) / (equals ws number) / (between_op ws number ws AND ws number)

    # Operators
    equals = "="
    not_equals = "!=" / "<>"
    gte = ">="
    lte = "<="
    gt = ">"
    lt = "<"
    in_op = IN
    not_in_op = NOT ws IN
    like_op = LIKE
    between_op = BETWEEN
    not_between_op = NOT ws BETWEEN

    # Value types
    value = list_value / "[]" / string / number / boolean / date_string

    # Allow empty list for IN/NOT IN
    list_value = "(" ws (value (ws "," ws value)*)? ws ")"
    string = ~r"'(?:[^'\\\\]|\\\\.)*'"
    number = ~r"-?\d+(?:\.\d+)?"
    boolean = TRUE / FALSE
    date_string = ~r"'\\d{4}-\\d{2}-\\d{2}(T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z?)?'"

    # Keywords (case-insensitive, must not be followed by a word char)
    AND = ~r"and(?![a-zA-Z0-9_])"i
    OR = ~r"or(?![a-zA-Z0-9_])"i
    NOT = ~r"not(?![a-zA-Z0-9_])"i
    IN = ~r"in(?![a-zA-Z0-9_])"i
    LIKE = ~r"like(?![a-zA-Z0-9_])"i
    IS = ~r"is(?![a-zA-Z0-9_])"i
    NULL = ~r"null(?![a-zA-Z0-9_])"i
    EMPTY = ~r"empty(?![a-zA-Z0-9_])"i
    TRUE = ~r"true(?![a-zA-Z0-9_])"i
    FALSE = ~r"false(?![a-zA-Z0-9_])"i
    BETWEEN = ~r"between(?![a-zA-Z0-9_])"i
    COUNT = ~r"count(?![a-zA-Z0-9_])"i

    # Identifier for field names
    identifier = ~r"[a-zA-Z_][a-zA-Z0-9_\[\].]*"

    # Whitespace (to be ignored by the visitor)
    ws = ~r"\s*"
    """,  # noqa: E501
)


class QdrantFilterVisitor(NodeVisitor):
    """
    Traverse the parse tree generated by Parsimonious and build a Qdrant Filter object.
    Each method corresponds to a rule in the grammar.
    """

    def visit_expression(self, node: Node, visited_children: Any) -> models.Filter:
        result: Any = visited_children[0]
        rest: Any = visited_children[1]

        def ensure_list(val: Any) -> List[Any]:
            if val is None:
                return []
            if isinstance(val, list):
                return val
            return [val]

        def dedup(lst: List[Any]) -> List[Any]:
            # Remove duplicates while preserving order
            seen: set = set()
            out: List[Any] = []
            for x in lst:
                if id(x) not in seen:
                    out.append(x)
                    seen.add(id(x))
            return out

        def merge_filters(op: str, left: Any, right: Any) -> models.Filter:
            if op == "AND":

                def extract_must(f: Any) -> List[Any]:
                    if isinstance(f, models.Filter) and f.must and not f.should:
                        return ensure_list(f.must)
                    if (
                        isinstance(f, models.Filter)
                        and not f.must
                        and not f.should
                        and not f.must_not
                    ):
                        return []
                    if (
                        isinstance(f, models.Filter)
                        and f.should
                        and not f.must
                        and not f.must_not
                    ):
                        return [f]
                    if isinstance(f, models.Filter) and f.must:
                        return ensure_list(f.must)
                    if isinstance(f, models.Filter):
                        return []
                    if f is not None:
                        return [f]
                    return []

                def extract_must_not(f: Any) -> List[Any]:
                    if isinstance(f, models.Filter) and f.must_not and not f.should:
                        return ensure_list(f.must_not)
                    if (
                        isinstance(f, models.Filter)
                        and not f.must
                        and not f.should
                        and not f.must_not
                    ) or (
                        isinstance(f, models.Filter)
                        and f.should
                        and not f.must
                        and not f.must_not
                    ):
                        return []
                    if isinstance(f, models.Filter) and f.must_not:
                        return ensure_list(f.must_not)
                    if isinstance(f, models.Filter):
                        return []
                    return []

                must: List[Any] = extract_must(left) + extract_must(right)
                must_not: List[Any] = extract_must_not(left) + extract_must_not(right)
                must = dedup(_clean_filter_list(must))
                must_not = dedup(_clean_filter_list(must_not))
                return models.Filter(must=must or None, must_not=must_not or None)

            # OR
            # Flatten all must, must_not, and should conditions into should
            def flatten_should(f: Any) -> List[Any]:
                f = _unwrap_group(f)
                out: List[Any] = []
                if isinstance(f, models.Filter):
                    # If it's an OR filter already, flatten its shoulds
                    if f.should and not f.must and not f.must_not:
                        out.extend(ensure_list(f.should))
                    # Otherwise, add the whole filter
                    else:
                        out.append(f)
                elif f is not None:
                    out.append(f)
                return out

            should: List[Any] = flatten_should(left) + flatten_should(right)
            should = dedup(_clean_filter_list(should))
            return models.Filter(should=should or None)

        for op, term in rest:
            op_str: Optional[str] = None
            if hasattr(op, "text"):
                op_str = op.text.upper()
            elif isinstance(op, list):
                for o in op:
                    if hasattr(o, "text"):
                        op_str = o.text.upper()
                        break
                    if isinstance(o, str):
                        op_str = o.upper()
                        break
            if not op_str and isinstance(op, str):
                op_str = op.upper()
            if not op_str:
                raise ValueError(f"Could not extract logical operator from {op}")
            result = merge_filters(op_str, result, term)
        if not isinstance(result, models.Filter):
            return models.Filter(must=_clean_filter_list([result]))
        if result.must:
            result.must = _clean_filter_list(result.must)
            if not result.must:
                result.must = None
        if result.should:
            result.should = _clean_filter_list(result.should)
            if not result.should:
                result.should = None
        if result.must_not:
            result.must_not = _clean_filter_list(result.must_not)
            if not result.must_not:
                result.must_not = None
        return result

    def visit_factor(self, node: Node, visited_children: Any) -> models.Filter:
        """Handles NOT for any logic_term (including parenthesized expressions)"""
        # visited_children: [not_part, [term]]
        not_part: Any = visited_children[0]
        term: Any = _unwrap_group(visited_children[1])

        if not_part:  # Only apply NOT logic if not_part is not empty
            if not isinstance(term, models.Filter):
                return models.Filter(must_not=[term] if term is not None else None)

            # Handle double negation: NOT (must_not [...]) -> must [...]
            if term.must_not and not term.must and not term.should:
                return models.Filter(must=term.must_not)

            # For all other filters, wrap them in must_not
            return models.Filter(must_not=[term])

        # If NOT is not present, just return the term as-is
        return term

    def visit_condition(self, node: Node, visited_children: Any) -> Any:
        return visited_children[0]

    def visit_comparison(self, node: Node, visited_children: Any) -> models.Filter:
        """Handles all standard comparisons: =, !=, >, IN, BETWEEN, NOT IN, NOT BETWEEN etc."""
        identifier: str = visited_children[0]
        op_details: Any = (
            visited_children[2][0]
            if isinstance(visited_children[2], list) and visited_children[2]
            else visited_children[2]
        )
        if not isinstance(op_details, list):
            op_details = [op_details]
        op_text: Any = op_details[0]
        # Normalize op_text to a string for all cases
        if isinstance(op_text, list):
            op_text = " ".join(str(x) for x in op_text)
        value: Any = op_details[1] if len(op_details) > 1 else None

        def flatten_all(val: Any) -> List[Any]:
            if isinstance(val, list):
                out: List[Any] = []
                for v in val:
                    out.extend(flatten_all(v))
                return out
            if val is not None:
                return [val]
            return []

        # Handle BETWEEN
        if op_text == "BETWEEN":
            val1 = op_details[1]
            val2 = op_details[3]
            cond = models.FieldCondition(
                key=identifier,
                range=models.Range(gte=val1, lte=val2),
            )
            result = models.Filter(must=[cond])
            return result
        if op_text == "NOT BETWEEN":
            val1 = op_details[1]
            val2 = op_details[3]
            cond = models.FieldCondition(
                key=identifier,
                range=models.Range(gte=val1, lte=val2),
            )
            result = models.Filter(must_not=[cond])
            return result
        if op_text == "=":
            if value is None:
                raise ValueError(
                    f"Missing value for '=' comparison on field {identifier}",
                )
            cond = models.FieldCondition(
                key=identifier,
                match=models.MatchValue(value=value),
            )
            result = models.Filter(must=[cond])
            return result
        if op_text in ("!=", "<>"):
            if value is None:
                raise ValueError(
                    f"Missing value for '!=' comparison on field {identifier}",
                )
            cond = models.FieldCondition(
                key=identifier,
                match=models.MatchValue(value=value),
            )
            result = models.Filter(must_not=[cond])
            return result
        if op_text == "IN":
            if value is None:
                raise ValueError(
                    f"Missing value for 'IN' comparison on field {identifier}",
                )
            clean_value = flatten_all(value)
            cond = models.FieldCondition(
                key=identifier,
                match=models.MatchAny(any=clean_value),
            )
            result = models.Filter(must=[cond])
            return result
        if op_text == "NOT IN":
            if value is None:
                raise ValueError(
                    f"Missing value for 'NOT IN' comparison on field {identifier}",
                )
            clean_value = flatten_all(value)
            cond = models.FieldCondition(
                key=identifier,
                match=models.MatchAny(any=clean_value),
            )
            result = models.Filter(must_not=[cond])
            return result
        if op_text == "LIKE":
            if value is None:
                raise ValueError(
                    f"Missing value for 'LIKE' comparison on field {identifier}",
                )
            cond = models.FieldCondition(
                key=identifier,
                match=models.MatchText(text=value),
            )
            result = models.Filter(must=[cond])
            return result
        # Handle range conditions
        range_kwargs = {}
        if op_text == ">":
            range_kwargs["gt"] = value
        elif op_text == ">=":
            range_kwargs["gte"] = value
        elif op_text == "<":
            range_kwargs["lt"] = value
        elif op_text == "<=":
            range_kwargs["lte"] = value
        if isinstance(value, str):
            try:
                datetime.datetime.fromisoformat(value.replace("Z", "+00:00"))
                cond = models.FieldCondition(
                    key=identifier,
                    range=models.DatetimeRange(**range_kwargs),
                )
                result = models.Filter(must=[cond])
                return result
            except (ValueError, TypeError):
                pass
        cond = models.FieldCondition(key=identifier, range=models.Range(**range_kwargs))
        result = models.Filter(must=[cond])
        return result

    def visit_is_null_condition(
        self, _node: Node, visited_children: Any
    ) -> models.Filter:
        """Handle IS NULL and IS NOT NULL conditions."""
        identifier = visited_children[0]
        not_op = (
            visited_children[VISITED_CHILDREN_NOT_OP_INDEX]
            if len(visited_children) > VISITED_CHILDREN_NOT_OP_INDEX
            else None
        )
        condition = models.IsNullCondition(is_null=models.PayloadField(key=identifier))
        if not_op:
            return models.Filter(must_not=[condition])
        return models.Filter(must=[condition])

    def visit_is_empty_condition(
        self, _node: Node, visited_children: Any
    ) -> models.Filter:
        """Handle IS EMPTY condition."""
        cond = models.IsEmptyCondition(
            is_empty=models.PayloadField(key=visited_children[0])
        )
        return models.Filter(must=[cond])

    def visit_is_empty_array_condition(
        self, _node: Node, visited_children: Any
    ) -> models.Filter:
        """Handle = [] (empty array) condition."""
        cond = models.IsEmptyCondition(
            is_empty=models.PayloadField(key=visited_children[0])
        )
        return models.Filter(must=[cond])

    def visit_has_id_condition(
        self, _node: Node, visited_children: Any
    ) -> models.Filter:
        """Handle id = ... and id IN (...) conditions."""
        filtered = [x for x in visited_children if x is not None]
        if len(filtered) == FILTERED_ID_OP_VALUE_LEN:
            _, op, value = filtered
        elif len(filtered) > FILTERED_ID_OP_VALUE_LEN:
            _, op, *rest = filtered
            value = rest[-1]
            if isinstance(op, list):
                op = op[0]
        else:
            msg = f"Unexpected children for has_id_condition: {filtered}"
            raise ValueError(msg)
        op_str = (
            op.upper()
            if isinstance(op, str)
            else (op.text.upper() if hasattr(op, "text") else str(op).upper())
        )
        if op_str == "IN":
            cond = models.HasIdCondition(
                has_id=value if isinstance(value, list) else [value]
            )
        else:
            cond = models.HasIdCondition(
                has_id=[value] if not isinstance(value, list) else value
            )
        return models.Filter(must=[cond])

    def visit_values_count_condition(
        self, _node: Node, visited_children: Any
    ) -> models.Filter:
        """Handle COUNT(field) conditions."""
        identifier = visited_children[3]
        op_details = (
            visited_children[7][0]
            if isinstance(visited_children[7], list) and visited_children[7]
            else visited_children[7]
        )
        if not isinstance(op_details, list):
            op_details = [op_details]
        op_text = op_details[0]
        count_kwargs = {}
        if op_text == "BETWEEN":
            val1 = op_details[1]
            val2 = op_details[3]
            count_kwargs["gte"] = val1
            count_kwargs["lte"] = val2
        else:
            number = op_details[1]
            if op_text == ">":
                count_kwargs["gt"] = number
            elif op_text == ">=":
                count_kwargs["gte"] = number
            elif op_text == "<":
                count_kwargs["lt"] = number
            elif op_text == "<=":
                count_kwargs["lte"] = number
            elif op_text == "=":
                count_kwargs["gte"] = count_kwargs["lte"] = number
        cond = models.FieldCondition(
            key=identifier, values_count=models.ValuesCount(**count_kwargs)
        )
        return models.Filter(must=[cond])

    def visit_value(self, _node: Node, visited_children: Any) -> Any:
        """Extract value for string, number, boolean, date_string, list_value, or empty list."""
        val = visited_children[0]

        def flatten(x: Any) -> List[Any]:
            if isinstance(x, list):
                out = []
                for i in x:
                    out.extend(flatten(i))
                return out
            elif x is not None:
                return [x]
            else:
                return []

        if isinstance(val, list):
            return flatten(val)
        if isinstance(val, str):
            if val.startswith("'") and val.endswith("'"):
                return val[1:-1].replace("\\'", "'").replace("\\\\", "\\")
            return val
        return val

    def visit_list_value(self, _node: Node, visited_children: Any) -> List[Any]:
        """Extract list of values from a parenthesized value list."""
        values = []

        def flatten(x: Any) -> None:
            if isinstance(x, list):
                for i in x:
                    flatten(i)
            elif x is not None and x not in {"", ","}:
                values.append(x)

        v = (
            visited_children[VISITED_CHILDREN_VALUE_INDEX]
            if len(visited_children) > VISITED_CHILDREN_VALUE_INDEX
            else None
        )
        flatten(v)
        tail = (
            visited_children[VISITED_CHILDREN_TAIL_INDEX]
            if len(visited_children) > VISITED_CHILDREN_TAIL_INDEX
            else None
        )
        if isinstance(tail, list):
            for t in tail:
                if isinstance(t, (list, tuple)) and len(t) == 2:
                    val = t[1]
                    flatten(val)
        return values

    def visit_string(self, _node: Node, _visited_children: Any) -> str:
        """Extract string value, unquoting and unescaping as needed."""
        return _node.text[1:-1].replace("\\'", "'")

    def visit_number(self, _node: Node, _visited_children: Any) -> Union[int, float]:
        """Extract number value as int or float."""
        return float(_node.text) if "." in _node.text else int(_node.text)

    def visit_boolean(self, _node: Node, _visited_children: Any) -> bool:
        """Extract boolean value."""
        return _node.text.lower() == "true"

    def visit_date_string(self, _node: Node, _visited_children: Any) -> str:
        """Extract date string value, unquoting as needed."""
        return _node.text[1:-1]

    def visit_identifier(self, _node: Node, _visited_children: Any) -> str:
        """Extract identifier string."""
        return _node.text

    def generic_visit(self, _node: Node, visited_children: Any) -> Any:
        """Remove all None values from visited children."""
        return [child for child in visited_children if child is not None] or _node.text

    def visit_ws(self, _node: Node, _visited_children: Any) -> None:
        """Discard whitespace nodes."""
        return None


def _clean_filter_list(lst: Any) -> List[Any]:
    """Remove any non-Qdrant objects (like '(', ')', None, whitespace) from lists."""
    valid_types = (
        models.FieldCondition,
        models.IsEmptyCondition,
        models.IsNullCondition,
        models.HasIdCondition,
        models.HasVectorCondition,
        models.NestedCondition,
        models.Filter,
    )
    out = []
    for x in lst:
        if x is None:
            continue
        if isinstance(x, valid_types):
            out.append(x)
        elif isinstance(x, list):
            out.extend(_clean_filter_list(x))
    return out


def _unwrap_group(val: Any) -> Any:
    """Recursively extract the first valid Qdrant object from lists/tuples."""
    valid_types = (
        models.FieldCondition,
        models.IsEmptyCondition,
        models.IsNullCondition,
        models.HasIdCondition,
        models.HasVectorCondition,
        models.NestedCondition,
        models.Filter,
    )
    if isinstance(val, models.Filter):
        must = (
            val.must
            if isinstance(val.must, list)
            else ([val.must] if val.must is not None else [])
        )
        should = (
            val.should
            if isinstance(val.should, list)
            else ([val.should] if val.should is not None else [])
        )
        must_not = (
            val.must_not
            if isinstance(val.must_not, list)
            else ([val.must_not] if val.must_not is not None else [])
        )
        if must and len(must) == 1 and not should and not must_not:
            return _unwrap_group(must[0])
        if should and len(should) == 1 and not must and not must_not:
            return _unwrap_group(should[0])
        return val
    if isinstance(val, valid_types):
        return val
    if isinstance(val, (list, tuple)):
        for v in val:
            unwrapped = _unwrap_group(v)
            if unwrapped is not None:
                return unwrapped
        return None
    return None


def parse_where_to_filter(query: str) -> models.Filter:
    """Parse a SQL-like WHERE clause string into a Qdrant Filter object."""
    tree = qdrant_filter_grammar.parse(query)
    visitor = QdrantFilterVisitor()
    result = visitor.visit(tree)
    if not isinstance(result, models.Filter):
        if result:
            return models.Filter(must=[result])
        return models.Filter()
    return result
